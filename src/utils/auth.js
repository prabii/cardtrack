import Cookies from 'js-cookie';

// Token storage keys
const ACCESS_TOKEN_KEY = 'access_token';
const REFRESH_TOKEN_KEY = 'refresh_token';

// Token expiration times (in milliseconds)
const ACCESS_TOKEN_EXPIRY = 15 * 60 * 1000; // 15 minutes
const REFRESH_TOKEN_EXPIRY = 7 * 24 * 60 * 60 * 1000; // 7 days

/**
 * Generate mock JWT tokens (for demo purposes)
 * In a real application, tokens would be generated by the backend
 * @param {Object} payload - User data to encode in token
 * @returns {Object} - Object containing access and refresh tokens
 */
export const generateTokens = (payload) => {
  const now = Date.now();
  
  // Create mock JWT-like tokens with expiration
  const accessTokenPayload = {
    ...payload,
    iat: Math.floor(now / 1000),
    exp: Math.floor((now + ACCESS_TOKEN_EXPIRY) / 1000),
    type: 'access'
  };
  
  const refreshTokenPayload = {
    ...payload,
    iat: Math.floor(now / 1000),
    exp: Math.floor((now + REFRESH_TOKEN_EXPIRY) / 1000),
    type: 'refresh'
  };
  
  // Create mock JWT tokens (base64 encoded JSON)
  const accessToken = btoa(JSON.stringify(accessTokenPayload));
  const refreshToken = btoa(JSON.stringify(refreshTokenPayload));
  
  return {
    accessToken,
    refreshToken
  };
};

/**
 * Verify mock JWT token
 * @param {string} token - JWT token to verify
 * @returns {Object|null} - Decoded token payload or null if invalid
 */
export const verifyToken = (token) => {
  try {
    if (!token) return null;
    
    // Check if it's a real JWT token (has dots) or mock token
    if (token.includes('.')) {
      // Real JWT token from backend - decode the payload part
      const parts = token.split('.');
      if (parts.length !== 3) {
        console.log('Invalid JWT format');
        return null;
      }
      
      // Decode the payload (second part)
      const payload = JSON.parse(atob(parts[1]));
      
      // Check if token is expired
      const now = Math.floor(Date.now() / 1000);
      if (payload.exp && payload.exp < now) {
        console.log('Token expired');
        return null;
      }
      
      return payload;
    } else {
      // Mock token (base64 encoded JSON)
      const payload = JSON.parse(atob(token));
      
      // Check if token is expired
      const now = Math.floor(Date.now() / 1000);
      if (payload.exp && payload.exp < now) {
        console.log('Token expired');
        return null;
      }
      
      return payload;
    }
  } catch (error) {
    console.error('Token verification failed:', error);
    return null;
  }
};

/**
 * Store tokens in cookies
 * @param {string} accessToken - Access token
 * @param {string} refreshToken - Refresh token
 */
export const storeTokens = (accessToken, refreshToken) => {
  // Store access token (shorter expiry)
  Cookies.set(ACCESS_TOKEN_KEY, accessToken, { 
    expires: 1, // 1 day
    secure: import.meta.env.PROD,
    sameSite: 'strict'
  });
  
  // Store refresh token (longer expiry)
  Cookies.set(REFRESH_TOKEN_KEY, refreshToken, { 
    expires: 7, // 7 days
    secure: import.meta.env.PROD,
    sameSite: 'strict'
  });
};

/**
 * Get stored access token
 * @returns {string|null} - Access token or null if not found
 */
export const getAccessToken = () => {
  // Check cookies first, then localStorage as fallback
  return Cookies.get(ACCESS_TOKEN_KEY) || localStorage.getItem('accessToken') || null;
};

/**
 * Get stored refresh token
 * @returns {string|null} - Refresh token or null if not found
 */
export const getRefreshToken = () => {
  // Check cookies first, then localStorage as fallback
  return Cookies.get(REFRESH_TOKEN_KEY) || localStorage.getItem('refreshToken') || null;
};

/**
 * Remove all stored tokens
 */
export const clearTokens = () => {
  // Clear from cookies
  Cookies.remove(ACCESS_TOKEN_KEY);
  Cookies.remove(REFRESH_TOKEN_KEY);
  
  // Clear from localStorage as well
  localStorage.removeItem('accessToken');
  localStorage.removeItem('refreshToken');
  localStorage.removeItem('user');
};

/**
 * Check if user is authenticated
 * @returns {boolean} - True if user has valid access token
 */
export const isAuthenticated = () => {
  const token = getAccessToken();
  if (!token) return false;
  
  // Check if user is stored in localStorage (for admin login)
  const storedUser = localStorage.getItem('user');
  if (storedUser) {
    try {
      const user = JSON.parse(storedUser);
      return user && user.id && user.email;
    } catch (e) {
      console.error('Error parsing stored user:', e);
    }
  }
  
  // Fallback to token verification
  const decoded = verifyToken(token);
  return decoded !== null;
};

/**
 * Get current user from token
 * @returns {Object|null} - User data or null if not authenticated
 */
export const getCurrentUser = () => {
  const token = getAccessToken();
  if (!token) return null;
  
  // First try to get user from localStorage (for admin login)
  const storedUser = localStorage.getItem('user');
  if (storedUser) {
    try {
      const user = JSON.parse(storedUser);
      return user;
    } catch (e) {
      console.error('Error parsing stored user:', e);
    }
  }
  
  // Fallback to token verification
  return verifyToken(token);
};

/**
 * Refresh access token using refresh token
 * @returns {string|null} - New access token or null if refresh failed
 */
export const refreshAccessToken = () => {
  const refreshToken = getRefreshToken();
  if (!refreshToken) return null;
  
  const decoded = verifyToken(refreshToken);
  if (!decoded) {
    clearTokens();
    return null;
  }
  
  // Generate new access token
  const now = Date.now();
  const newAccessTokenPayload = {
    id: decoded.id,
    email: decoded.email,
    name: decoded.name,
    iat: Math.floor(now / 1000),
    exp: Math.floor((now + ACCESS_TOKEN_EXPIRY) / 1000),
    type: 'access'
  };
  
  const newAccessToken = btoa(JSON.stringify(newAccessTokenPayload));
  
  // Store new access token
  Cookies.set(ACCESS_TOKEN_KEY, newAccessToken, { 
    expires: 1,
    secure: import.meta.env.PROD,
    sameSite: 'strict'
  });
  
  return newAccessToken;
};

/**
 * API request interceptor to add auth header
 * @param {Object} config - Axios config object
 * @returns {Object} - Modified config with auth header
 */
export const addAuthHeader = (config) => {
  const token = getAccessToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
};

/**
 * Handle API response to check for token expiration
 * @param {Object} error - Axios error object
 * @returns {Promise} - Promise that resolves to retry request or rejects
 */
export const handleTokenExpiration = async (error) => {
  if (error.response?.status === 401) {
    const newToken = refreshAccessToken();
    if (newToken) {
      // Retry the original request with new token
      error.config.headers.Authorization = `Bearer ${newToken}`;
      return error.config;
    } else {
      // Refresh failed, redirect to login
      clearTokens();
      window.location.href = '/login';
      return Promise.reject(error);
    }
  }
  return Promise.reject(error);
};

